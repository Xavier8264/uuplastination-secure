<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Plastination Control System – Secure</title>
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#0B0B0F" />
  <link rel="stylesheet" href="assets/styles/design-tokens.css" />
  <style>
    /* Map existing component variables to design tokens for Apple-inspired dark mode */
    :root {
      --bg: var(--background);
      --panel: var(--surface);
      --panel-2: var(--surface-2);
      --border: var(--border);
      --text: var(--text);
      --muted: var(--text-secondary);
      --primary: var(--accent);
      --accent: var(--positive);
      --success: var(--positive);
      --warning: var(--warning);
      --danger: var(--danger);
      --shadow: var(--shadow-subtle);
      --radius: var(--radius-md);
    }
    @media (prefers-color-scheme: light) {
      :root {
        /* In light mode the token system already flips; keep mapping consistent */
        --bg: var(--background);
        --panel: var(--surface);
        --panel-2: var(--surface-2);
        --border: var(--border);
        --text: var(--text);
        --muted: var(--text-secondary);
        --primary: var(--accent);
        --accent: var(--positive);
        --success: var(--positive);
        --warning: var(--warning);
        --danger: var(--danger);
        --shadow: var(--shadow-subtle);
        --radius: var(--radius-md);
      }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: var(--bg);
      color:var(--text);
      font: 14px/1.5 var(--font-sans, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif);
      letter-spacing: -0.01em;
      font-weight: 400;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
    }
    header{
      position:sticky; top:0; z-index:5;
      display:flex; align-items:center; gap:16px; justify-content:space-between;
      padding:16px 24px; border-bottom:1px solid var(--divider);
      background: var(--panel);
      backdrop-filter: blur(24px) saturate(1.6);
      -webkit-backdrop-filter: blur(24px) saturate(1.6);
      box-shadow: var(--shadow-sm);
    }
    .title{font-size:20px; font-weight:600; letter-spacing:-0.02em}
  .chip{display:inline-flex; align-items:center; gap:8px; padding:6px 12px; border:1px solid var(--border); border-radius:16px; color:var(--text-secondary); background:var(--surface-3); backdrop-filter: blur(12px)}
  .btn{display:inline-flex; align-items:center; justify-content:center; gap:8px; padding:8px 16px; border:1px solid var(--border); background:var(--surface-2); color:var(--text); border-radius:8px; cursor:pointer; transition:all var(--transition-base); box-shadow:var(--shadow-sm); font-weight:500; font-size:14px; backdrop-filter: blur(12px)}
  .btn:hover{transform:translateY(-2px); box-shadow:var(--shadow-md); border-color:var(--border-hover)}
    .btn:active{transform:translateY(0); box-shadow:var(--shadow)}
    .btn:disabled{opacity:.4; cursor:not-allowed; transform:none}
  .btn.primary{background:var(--primary); border-color:var(--primary); color:#fff; font-weight:600}
  .btn.primary:hover{background:var(--accent-hover); border-color:var(--accent-hover)}
  .btn.danger{background:var(--danger); border-color:var(--danger); color:#fff; font-weight:600}
  .btn.danger:hover{filter:brightness(1.15)}

    main{max-width:1600px; margin:20px auto; padding:0 24px}
    .grid{display:grid; grid-template-columns: 7fr 3fr; gap:20px}
    @media (max-width:1100px){ .grid{grid-template-columns: 1fr;}}
  .card{background:var(--panel); border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow-subtle); overflow:hidden; backdrop-filter: blur(24px)}
  .card h3{margin:0; font-size:12px; font-weight:600; color:var(--text-secondary); text-transform:uppercase; letter-spacing:0.08em}
  .card .hdr{display:flex; align-items:center; justify-content:space-between; gap:12px; padding:16px 20px; border-bottom:1px solid var(--divider); background: var(--surface-2)}
    .card .body{padding:20px}
    .muted{color:var(--muted)}
    .mono{font-family: "SF Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-weight:500}

    /* camera */
  .camera-wrap{position:relative; aspect-ratio:16/9; background:#000; border:1px solid var(--border); border-radius:var(--radius); overflow:hidden}
    /* Fallback for browsers without aspect-ratio support */
    @supports not (aspect-ratio: 16/9) {
      .camera-wrap::before{content:""; display:block; padding-top:56.25%;}
      .camera-wrap > *{position:absolute; inset:0}
    }
    .camera-wrap img, .camera-wrap video, .camera-wrap canvas{position:absolute; inset:0; width:100%; height:100%; object-fit:cover}
  .badge{display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:12px; font-size:11px; border:1px solid var(--border); background:var(--surface-3); font-weight:500; backdrop-filter: blur(12px)}
    .badge.success{background:rgba(48, 209, 88, 0.1); color:var(--success); border-color:rgba(48, 209, 88, 0.2)}
    .badge.warn{background:rgba(255, 149, 0, 0.1); color:var(--warning); border-color:rgba(255, 149, 0, 0.2)}
  .badge.info{background:var(--info-bg); color:var(--info); border-color:var(--info-border)}

    /* valve */
  .range-bar{position:relative; height:8px; border-radius:4px; background:var(--surface-3); border:none; overflow:hidden}
    .range-bar > div{position:absolute; inset:0 0 0 0; transform-origin:left center; background:linear-gradient(90deg, var(--primary), var(--accent)); border-radius:4px}
    .valve-grid{display:grid; grid-template-columns:1fr 1fr; gap:12px}

    /* chart */
  .chart{height:280px; background:var(--surface-2); border:1px solid var(--border); border-radius:var(--radius); position:relative}
    .ylabels{position:absolute; left:12px; top:12px; bottom:12px; display:flex; flex-direction:column; justify-content:space-between; color:var(--muted); font-size:11px; font-weight:500}

    /* status table */
  .kv{display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 0; border-bottom:1px solid var(--divider)}
    .kv:last-child{border-bottom:none}

    .footer{margin:12px 0 0; font-size:12px; color:var(--text-tertiary); font-weight:400}
  </style>
</head>
<body>
  <header>
    <div class="title">Plastination Control System</div>
    <div class="chip mono" id="rec-chip">
      <span id="rec-dot">●</span>
      <span id="rec-label">Standby</span>
    </div>
    <div style="display:flex; gap:10px">
      <button class="btn" id="toggle-record">Toggle Recording</button>
      <a class="btn danger" href="/logout">Logout</a>
    </div>
  </header>

  <main>
    <div class="grid">
      <!-- Left column (≈70%) -->
      <section style="display:flex; flex-direction:column; gap:20px">
        <!-- Camera Feed -->
        <div class="card">
          <div class="hdr">
            <h3>Live Camera Feed</h3>
            <div style="display:flex; gap:8px; align-items:center">
              <span class="badge success" id="cam-status">● Connected</span>
              <span class="badge" id="bubble-chip">0 bubbles detected</span>
            </div>
          </div>
          <div class="body">
            <div class="camera-wrap">
              <!-- MJPEG fallback stream (relative path so it works under /secure/) -->
                  <img id="cam" alt="Camera stream" src="${location.pathname.startsWith('/secure/')?'/secure':''}/camera/stream.mjpg" 
                    onload="if(!window._webrtcActive){const s=document.getElementById('cam-status');s.textContent='● MJPEG';s.className='badge';window._mjpegFirstFrameTs=Date.now();console.log('MJPEG stream loaded');}" 
                    onerror="this.dataset.err=1;const s=document.getElementById('cam-status');s.textContent='MJPEG Error';s.className='badge warn';console.error('MJPEG stream failed to load');" 
                    style="display:block">
              <!-- WebRTC live video element (hidden until connected) -->
              <video id="webrtcVideo" autoplay playsinline muted style="display:none"></video>
              <!-- Lightweight overlay canvas for future detections -->
              <canvas id="overlay"></canvas>
              <div style="position:absolute; left:12px; bottom:12px; display:flex; gap:8px">
                <span class="badge mono" id="cam-meta">Initializing...</span>
                <span class="badge mono" id="clock"></span>
              </div>
            </div>
          </div>
        </div>

        <!-- Tank HLS Stream (RTMP->HLS) -->
        <div class="card">
          <div class="hdr">
            <h3>Plastination Tank HLS Stream</h3>
            <span class="badge" id="hls-status">Initializing…</span>
          </div>
          <div class="body">
            <div class="camera-wrap">
              <video id="tankStream" controls autoplay playsinline muted poster="" style="background:#000"></video>
              <div style="position:absolute; left:12px; bottom:12px; display:flex; gap:8px">
                <span class="badge mono" id="hls-meta">HLS • awaiting segments</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Bubble Rate History (placeholder; regenerates mock data) -->
        <div class="card">
          <div class="hdr">
            <h3>Bubble Rate History</h3>
            <div style="display:flex; gap:8px">
              <div style="display:flex; gap:6px">
                <button class="btn" data-range="1h">1h</button>
                <button class="btn" data-range="6h">6h</button>
                <button class="btn" data-range="24h">24h</button>
                <button class="btn" data-range="7d">7d</button>
              </div>
              <button id="export" class="btn">Export CSV</button>
            </div>
          </div>
          <div class="body">
            <div class="chart" id="chart">
              <svg id="chart-svg" viewBox="0 0 1000 300" width="100%" height="100%"></svg>
              <div class="ylabels mono" id="ylabels"></div>
            </div>
            <div class="footer mono" id="points">0 data points</div>
          </div>
        </div>
      </section>

      <!-- Right column (≈30%) -->
      <aside style="display:flex; flex-direction:column; gap:20px">
        <!-- Valve Control (Simplified) -->
        <div class="card">
          <div class="hdr"><h3>Manual Valve Control</h3><span class="badge" id="valve-state">Ready</span></div>
          <div class="body">
            <div style="display:flex; gap:12px; justify-content:center; margin-top:4px;">
              <button id="valve-close" class="btn" style="flex:1">Close</button>
              <button id="valve-open"  class="btn primary" style="flex:1">Open</button>
            </div>
            <div class="footer mono" id="valve-api-status">Idle</div>
          </div>
        </div>

        <!-- Bubble Rate Stats -->
        <div class="card">
          <div class="hdr"><h3>Bubble Rate Monitor</h3><span class="badge" style="background:rgba(0, 122, 255, 0.1); color:var(--primary); border-color:rgba(0, 122, 255, 0.2)">● Live</span></div>
          <div class="body">
            <div style="display:flex; align-items:baseline; justify-content:space-between; margin-bottom:6px">
              <span class="muted">Current Rate</span>
              <span id="trend-icon" class="mono" title="trend">→</span>
            </div>
            <div style="display:flex; align-items:baseline; gap:10px; margin-bottom:16px">
              <span class="mono" id="rate-now" style="font-size:44px; font-weight:700; color:var(--primary)">24</span>
              <span class="muted">bubbles/min</span>
            </div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px">
              <div>
                <div class="muted" style="font-size:12px">Average (10 min)</div>
                <div class="mono" id="rate-avg" style="font-size:22px; font-weight:600">22</div>
              </div>
              <div>
                <div class="muted" style="font-size:12px">Trend</div>
                <div id="rate-trend" style="font-size:22px; font-weight:600; color:var(--muted)">→</div>
              </div>
              <div>
                <div class="muted" style="font-size:12px">Peak Rate</div>
                <div class="mono" id="rate-peak" style="font-size:22px; font-weight:600">27</div>
              </div>
              <div>
                <div class="muted" style="font-size:12px">Min Rate</div>
                <div class="mono" id="rate-min" style="font-size:22px; font-weight:600">17</div>
              </div>
            </div>
            <div class="footer">Detection: <span style="color:var(--success)">● Running</span></div>
          </div>
        </div>

        <!-- System Health -->
        <div class="card">
          <div class="hdr"><h3>System Health</h3><span class="badge success">All Systems Operational</span></div>
          <div class="body">
            <div class="kv"><span class="muted">CPU Temperature</span><strong class="mono" id="cpu-temp">52.0°C</strong></div>
            <div class="kv"><span class="muted">CPU Usage</span>
              <span class="mono"><span id="cpu-usage">34</span>%</span>
            </div>
            <div class="kv"><span class="muted">Memory</span><span class="mono" id="mem-usage">2.8 GB / 8 GB</span></div>
            <div class="kv"><span class="muted">Camera</span><span class="badge success" id="cam-badge">Active</span></div>
            <div class="kv"><span class="muted">Stepper Motor</span><span class="badge success" id="stepper-badge">Active</span></div>
            <div class="kv"><span class="muted">Network</span><span class="badge success">Active</span></div>
            <div class="footer">Raspberry Pi 5 (8GB) • Raspberry Pi OS 64‑bit • Uptime: <span id="uptime">4d 12h 34m</span></div>
          </div>
        </div>
      </aside>
    </div>
  </main>

  <script>
    // --- Config ---
    const BASE = location.pathname.startsWith('/secure/') ? '/secure' : '';
    const CONFIG = {
      valveOpen:  `${BASE}/api/valve/open`,
      valveClose: `${BASE}/api/valve/close`,
      metrics:    `${BASE}/api/system/metrics`,
      stepperStatus: `${BASE}/api/stepper/status`,
      // Choose ws/wss automatically if used in future
      bubblesWS:  `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}${BASE}/camera/stream`,
    };
    // Auth token for valve API (set VALVE_API_TOKEN env to match). Replace placeholder.
    const VALVE_TOKEN = "CHANGE_ME_TOKEN";

    // --- Header recording toggle (placeholder) ---
    const recBtn = document.getElementById('toggle-record');
    const recChip = document.getElementById('rec-chip');
    const recLabel = document.getElementById('rec-label');
    const recDot = document.getElementById('rec-dot');
    let isRecording = false;
    recBtn.addEventListener('click', async () => {
      isRecording = !isRecording;
      recLabel.textContent = isRecording ? 'Recording' : 'Standby';
      recDot.style.color = isRecording ? 'var(--danger)' : 'var(--muted)';
      // Optional: await fetch('/api/recording/toggle', {method:'POST'});
    });

    // --- Live clock on camera ---
    const clockEl = document.getElementById('clock');
    setInterval(()=> clockEl.textContent = new Date().toLocaleTimeString(), 1000);
    const camMetaEl = document.getElementById('cam-meta');

    // --- Camera bubble-detection chip (simulated) ---
    const bubbleChip = document.getElementById('bubble-chip');
    setInterval(()=>{
      const n = Math.floor(Math.random()*5);
      bubbleChip.textContent = `${n} bubble${n===1?'':'s'} detected`;
    }, 2000);

    // --- Valve control (simplified: only Open/Close) ---
    const stateEl = document.getElementById('valve-state');
    const valveApiStatus = document.getElementById('valve-api-status');
    const openBtn = document.getElementById('valve-open');
    const closeBtn = document.getElementById('valve-close');

    async function sendValve(url, label){
      stateEl.textContent = label + '…';
      valveApiStatus.textContent = 'Sending';
      openBtn.disabled = true; closeBtn.disabled = true;
      try {
        const res = await fetch(url, { method:'POST', credentials:'include', headers:{'Content-Type':'application/json'} });
        if(!res.ok){
          valveApiStatus.textContent = 'Error ' + res.status;
        } else {
          valveApiStatus.textContent = 'OK';
        }
      } catch(e){
        valveApiStatus.textContent = 'Network error';
      }
      stateEl.textContent = 'Ready';
      openBtn.disabled = false; closeBtn.disabled = false;
    }

    openBtn.addEventListener('click', ()=> sendValve(CONFIG.valveOpen, 'Opening'));
    closeBtn.addEventListener('click', ()=> sendValve(CONFIG.valveClose, 'Closing'));

    // --- Bubble rate stats (simulated drift) ---
    const nowEl = document.getElementById('rate-now');
    const avgEl = document.getElementById('rate-avg');
    const peakEl = document.getElementById('rate-peak');
    const minEl = document.getElementById('rate-min');
    const trendTxt = document.getElementById('rate-trend');
    const trendIcon = document.getElementById('trend-icon');
    let rateNow = 24, rateAvg = 22;
    function updateRates(){
      const newRate = Math.max(0, rateNow + (Math.random()-0.5)*6);
      const r = Math.round(newRate);
      const prev = rateNow; rateNow = r; rateAvg = Math.round((rateAvg*9 + r)/10);
      nowEl.textContent = rateNow; avgEl.textContent = rateAvg;
      peakEl.textContent = Math.max(rateNow, rateAvg+5);
      minEl.textContent = Math.max(0, rateAvg-5);
      let t='→', ic='→';
      if(r > prev+2){ t='↑'; ic='↑'; }
      else if(r < prev-2){ t='↓'; ic='↓'; }
      trendTxt.textContent = t; trendIcon.textContent = ic;
    }
    setInterval(updateRates, 3000);

    // --- System metrics (try backend, else simulate) ---
    const cpuTempEl  = document.getElementById('cpu-temp');
    const cpuUsageEl = document.getElementById('cpu-usage');
    const memUsageEl = document.getElementById('mem-usage');
    const uptimeEl   = document.getElementById('uptime');
    const stepperBadge = document.getElementById('stepper-badge');
    const camBadge = document.getElementById('cam-badge');
    
    async function tickMetrics(){
      try{
        const r = await fetch(CONFIG.metrics);
        if(r.ok){
          const m = await r.json();
          cpuTempEl.textContent  = `${m.cpuTemp.toFixed(1)}°C`;
          cpuUsageEl.textContent = `${Math.round(m.cpuUsage)}`;
          memUsageEl.textContent = `${m.memoryUsage.toFixed(1)} GB / ${m.memoryTotal.toFixed(1)} GB`;
          if(m.uptime) uptimeEl.textContent = m.uptime;
          return;
        }
      }catch(_){/* fallthrough to simulate */}
      // simulate
      const currT = parseFloat(cpuTempEl.textContent)||52;
      const currU = parseInt(cpuUsageEl.textContent)||34;
      const nextT = Math.max(40, Math.min(75, currT + (Math.random()-0.5)*3));
      const nextU = Math.max(10, Math.min(90, currU + (Math.random()-0.5)*10));
      cpuTempEl.textContent = `${nextT.toFixed(1)}°C`;
      cpuUsageEl.textContent = `${Math.round(nextU)}`;
    }
    
    async function tickStepperStatus(){
      try{
        const r = await fetch(CONFIG.stepperStatus);
        if(r.ok){
          const s = await r.json();
          if(s.enabled && s.moving === false){
            stepperBadge.className = 'badge success';
            stepperBadge.textContent = 'Active';
          } else if(s.moving){
            stepperBadge.className = 'badge warn';
            stepperBadge.textContent = 'Moving';
          } else {
            stepperBadge.className = 'badge';
            stepperBadge.textContent = 'Disabled';
          }
        }
      }catch(_){}
    }
    
    setInterval(tickMetrics, 3000);
    setInterval(tickStepperStatus, 1000);

    // --- Chart (SVG, mock data) ---
    const svg = document.getElementById('chart-svg');
    const ylabels = document.getElementById('ylabels');
    const pointsEl = document.getElementById('points');
    let timeRange = '1h';
    function genChart(){
      const N = 60; // points
      const now = Date.now();
      const data = Array.from({length:N}, (_,i)=>{
        const t = now - (N-i)*60000; // every minute
        const rate = Math.max(0, 20 + Math.random()*10 + Math.sin(i/5)*5);
        return {t, rate};
      });
      const rates = data.map(d=>d.rate);
      const min = Math.min(...rates);
      const max = Math.max(...rates);
      // grid
      svg.innerHTML = '';
      for(let i=0;i<5;i++){
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1','0'); line.setAttribute('y1', String(60*i));
        line.setAttribute('x2','1000'); line.setAttribute('y2', String(60*i));
        line.setAttribute('stroke','rgba(0,0,0,0.08)'); line.setAttribute('stroke-width','1'); line.setAttribute('opacity','0.6');
        svg.appendChild(line);
      }
      // polyline
      const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      const pts = data.map((d,i)=>{
        const x = (i/(data.length-1))*1000;
        const y = 280 - ((d.rate-min)/(max-min||1))*260;
        return `${x},${y}`;
      }).join(' ');
      poly.setAttribute('points', pts);
      poly.setAttribute('fill','none');
      poly.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--primary') || '#007aff');
      poly.setAttribute('stroke-width','2');
      svg.appendChild(poly);
      // area
      const area = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      area.setAttribute('points', pts + ' 1000,280 0,280');
      area.setAttribute('fill', '#007aff');
      area.setAttribute('opacity','0.08');
      svg.appendChild(area);
      // y labels
      ylabels.innerHTML = `<span>${max.toFixed(1)}</span><span>${(((max+min)/2)||0).toFixed(1)}</span><span>${min.toFixed(1)}</span>`;
      pointsEl.textContent = `${data.length} data points`;
    }
    genChart();
    setInterval(genChart, 5000);

    // time-range buttons (visual only; no backend yet)
    document.querySelectorAll('[data-range]').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        document.querySelectorAll('[data-range]').forEach(b=>b.classList.remove('primary'));
        e.currentTarget.classList.add('primary');
        timeRange = e.currentTarget.getAttribute('data-range');
        genChart();
      });
    });

  </script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    // Lightweight HLS player initialization for tank stream
    (function initHLS(){
      const statusEl = document.getElementById('hls-status');
      const metaEl = document.getElementById('hls-meta');
      const videoEl = document.getElementById('tankStream');
      if(!videoEl) return;
      // Support both direct /live/ and prefixed /secure/live/ playlist locations
      // Base-aware HLS: prefer path under /secure when dashboard served there
      const basePath = location.pathname.startsWith('/secure/') ? '/secure' : '';
      const primarySrc = `${basePath}/live/cam.m3u8`;
      const fallbackSrc = '/live/cam.m3u8'; // root fallback
      let src = primarySrc; // will switch to fallback if primary not found

      function setStatus(txt, cls){
        statusEl.textContent = txt;
        statusEl.className = 'badge' + (cls ? ' ' + cls : '');
      }

      async function checkHead(){
        try {
          const r = await fetch(src, { method:'GET', cache:'no-store' });
          if(r.ok){
            metaEl.textContent = src === primarySrc ? 'HLS • playlist OK' : 'HLS • fallback playlist OK';
            return true;
          }
        } catch(e) {}
        if(src === primarySrc){
          // Try fallback path once
          src = fallbackSrc;
          try {
            const r2 = await fetch(src, { method:'GET', cache:'no-store' });
            if(r2.ok){
              metaEl.textContent = 'HLS • fallback playlist OK';
              return true;
            }
          } catch(e2) {}
        }
        return false;
      }

      async function start(){
        const ready = await checkHead();
        if(!ready){
          setStatus('Waiting…', 'warn');
          setTimeout(start, 3000);
          return;
        }
        if(window.Hls && window.Hls.isSupported()){
          const hls = new window.Hls({
            maxBufferLength: 30,
            liveSyncDurationCount: 3,
            enableWorker: true,
          });
          hls.on(window.Hls.Events.ERROR, (_, data) => {
            if(data && data.fatal){
              setStatus('Error – retrying', 'warn');
              hls.destroy();
              setTimeout(start, 3000);
            }
          });
          hls.loadSource(src);
          hls.attachMedia(videoEl);
          videoEl.addEventListener('loadedmetadata', () => {
            setStatus('● Live', 'success');
            metaEl.textContent = 'HLS • ' + (videoEl.videoWidth||'') + 'x' + (videoEl.videoHeight||'');
          });
        } else if(videoEl.canPlayType('application/vnd.apple.mpegurl')) {
          videoEl.src = src;
          videoEl.addEventListener('loadedmetadata', () => {
            setStatus('● Live', 'success');
            metaEl.textContent = 'HLS • ' + (videoEl.videoWidth||'') + 'x' + (videoEl.videoHeight||'');
          });
        } else {
          setStatus('Unsupported', 'warn');
          metaEl.textContent = 'Browser lacks HLS support';
        }
      }
      start();
    })();
  </script>
  <script src="https://cdn.livekit.io/livekit-client-v1.15.3.min.js" crossorigin="anonymous"></script>
  <script>
    // Robust WebRTC connection attempt with retries and graceful fallback to MJPEG
    (function initWebRTC(){
      const statusEl = document.getElementById('cam-status');
      const imgEl = document.getElementById('cam');
      const videoEl = document.getElementById('webrtcVideo');
      const { Room, RoomEvent } = window.livekitClient || {};

      if(!Room){
        console.warn('LiveKit client not loaded; using MJPEG only');
        statusEl.textContent = '● MJPEG';
        statusEl.className = 'badge';
        return; // keep MJPEG
      }

      let backoff = 2000; // start at 2s
      let room;
      let retryTimer;
      let connectionAttempts = 0;
      const MAX_RETRY_ATTEMPTS = 10; // Stop retrying after 10 attempts

      async function tryConnect(){
        connectionAttempts++;
        
        if (connectionAttempts > MAX_RETRY_ATTEMPTS) {
          console.log('WebRTC max retry attempts reached; staying with MJPEG');
          statusEl.textContent = '● MJPEG (WebRTC unavailable)';
          statusEl.className = 'badge';
          window._webrtcActive = false;
          return;
        }
        
        try{
          statusEl.textContent = `Connecting WebRTC (${connectionAttempts})...`;
          statusEl.className = 'badge';
          
          const cfgResp = await fetch(`${BASE}/webrtc/config`, {cache:'no-store'});
          if(!cfgResp.ok) throw new Error('config http '+cfgResp.status);
          const cfg = await cfgResp.json();
          
          if(cfg.disabled){
            // WebRTC disabled by server-side flag; keep MJPEG
            console.log('WebRTC disabled by server config');
            window._webrtcActive = false;
            videoEl.style.display='none';
            imgEl.style.display='block';
            statusEl.textContent='● MJPEG';
            statusEl.className='badge';
            return;
          }
          
          if(!cfg.host){ 
            throw new Error('Missing host in /webrtc/config'); 
          }
          
          let host = cfg.host;
          if(typeof host === 'string' && !/^https?:\/\//i.test(host)){
            host = window.location.origin.replace(/\/$/, '') + (host.startsWith('/') ? host : ('/'+host));
          }
          
          const tokenResp = await fetch(`${BASE}/webrtc/token?room=plastination&role=viewer`, {cache:'no-store'});
          if(!tokenResp.ok) throw new Error('token http '+tokenResp.status);
          const { token } = await tokenResp.json();
          
          // Enable adaptive stream for better bandwidth behavior
          room = new Room({ adaptiveStream: true, dynacast: true });
          window._livekitRoom = room; // expose for debugging
          let haveVideo = false;
          
          room.on(RoomEvent.TrackSubscribed, (track, publication, _participant) => {
            try {
              if(publication.kind === 'video' && track){
                // Use LiveKit attach util for proper handling
                track.attach(videoEl);
                videoEl.style.display='block';
                imgEl.style.display='none';
                statusEl.textContent='● WebRTC Live';
                statusEl.className='badge success';
                window._webrtcActive = true;
                haveVideo = true;
                connectionAttempts = 0; // Reset on success
                console.log('WebRTC video track subscribed successfully');
              }
            } catch(e){ 
              console.warn('WebRTC track attach error', e); 
            }
          });
          
          room.on(RoomEvent.Disconnected, (reason) => {
            console.log('WebRTC disconnected:', reason);
            // Restore MJPEG on disconnect
            videoEl.style.display='none';
            imgEl.style.display='block';
            statusEl.textContent='● MJPEG';
            statusEl.className='badge';
            window._webrtcActive = false;
            scheduleRetry();
          });
          
          room.on(RoomEvent.ConnectionQualityChanged, (quality, participant) => {
            if (quality === 'poor') {
              console.warn('WebRTC connection quality is poor');
            }
          });

          await room.connect(host, token);
          console.log('WebRTC room connected, waiting for video track...');
          
          // If no video appears within 6s, keep MJPEG visible and schedule retry
          setTimeout(()=>{ 
            if(!haveVideo){ 
              console.log('No video track received within timeout');
              scheduleRetry(); 
            } 
          }, 6000);
          
        }catch(err){
          console.warn('WebRTC connect failed (attempt ' + connectionAttempts + '):', err);
          // Ensure MJPEG is visible
          videoEl.style.display='none';
          imgEl.style.display='block';
          window._webrtcActive = false;
          scheduleRetry();
        }
      }

      function scheduleRetry(){
        if (retryTimer) clearTimeout(retryTimer);
        
        statusEl.textContent = connectionAttempts >= MAX_RETRY_ATTEMPTS 
          ? '● MJPEG' 
          : 'Retrying WebRTC...';
        statusEl.className = 'badge';
        
        retryTimer = setTimeout(()=>{
          backoff = Math.min(backoff * 1.5, 30000); // Max 30s backoff
          tryConnect();
        }, backoff);
      }

      // Start initial connection
      window._pageLoadTs = Date.now();
      tryConnect();

      // Periodic camera status poll to keep badge accurate when on MJPEG
      async function pollCamera(){
        let statusData;
        try{
          const r = await fetch(`${BASE}/camera/status`, {cache:'no-store'});
          if(!r.ok) return;
          statusData = await r.json();
          
          if(window._webrtcActive) return; // don't override when WebRTC is active
          
          if(statusData && statusData.available){
            statusEl.textContent = statusData.running ? '● MJPEG' : 'Camera Standby';
            statusEl.className = statusData.running ? 'badge' : 'badge warn';
            // Update camera metadata from status if available
            if (statusData.resolution && statusData.framerate && camMetaEl) {
              camMetaEl.textContent = `${statusData.resolution} • ${statusData.framerate} FPS`;
              if (statusData.backend) {
                camMetaEl.textContent += ` • ${statusData.backend}`;
              }
            }
          }else{
            statusEl.textContent = 'Camera Unavailable';
            statusEl.className = 'badge warn';
            if (camMetaEl) {
              camMetaEl.textContent = 'No camera detected';
            }
          }
        }catch(err){
          console.warn('Camera status poll failed:', err);
        }
        // Initialization hint if MJPEG hasn't produced a frame
        if(!window._webrtcActive && (!statusData || !statusData.running)){
          if(Date.now() - window._pageLoadTs > 5000 && camMetaEl && !window._mjpegFirstFrameTs){
            camMetaEl.textContent = 'Waiting for MJPEG… (open /camera/stream.mjpg directly)';
          }
        }
      }
      
      setInterval(pollCamera, 5000);
      pollCamera(); // Initial poll
      
      // Also reflect WebRTC track dimensions when available
      if (videoEl) {
        videoEl.addEventListener('loadedmetadata', () => {
          if (camMetaEl && videoEl.videoWidth && videoEl.videoHeight) {
            camMetaEl.textContent = `${videoEl.videoWidth}×${videoEl.videoHeight} • WebRTC Live`;
          }
        });
      }
    })();
  </script>
</body>
</html>
