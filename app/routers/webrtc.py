from __future__ import annotations

import os
import time
import uuid
from typing import Any, Dict, List, Optional

import jwt
import json
import socket
import urllib.request
from fastapi import APIRouter, HTTPException, Query

router = APIRouter(prefix="/webrtc", tags=["webrtc"])


# Helpers to read env with defaults
# Prefer an HTTPS or proxy path to avoid mixed-content from HTTPS pages
LIVEKIT_HOST = os.getenv("LIVEKIT_HOST", "")
LIVEKIT_API_KEY = os.getenv("LIVEKIT_API_KEY", "")
LIVEKIT_API_SECRET = os.getenv("LIVEKIT_API_SECRET", "")
# Comma-separated list like: "stun:stun.l.google.com:19302,turns:turn.example.com:5349?transport=tcp"
LIVEKIT_ICE_SERVERS_RAW = os.getenv("LIVEKIT_ICE_SERVERS", "")
WEBRTC_DISABLE = os.getenv("WEBRTC_DISABLE", "0") not in ("0", "false", "False", "")


def _ice_servers() -> List[Dict[str, Any]]:
    urls_raw = [u.strip() for u in LIVEKIT_ICE_SERVERS_RAW.split(",") if u.strip()]
    if not urls_raw:
        return []
    # If using TURN static auth secret, you can generate ephemeral credentials here instead of static user/pass.
    # For now, return URL-only servers; coturn with static-auth-secret supports long-term creds, but LiveKit client
    # can use url-only for public TURN with no auth, which is NOT recommended. We encourage setting up TURN credentials.
    return [{"urls": urls_raw}]


def _build_access_token(identity: str, room: str, can_publish: bool = False) -> str:
    if not LIVEKIT_API_KEY or not LIVEKIT_API_SECRET:
        raise RuntimeError("LIVEKIT_API_KEY/SECRET not configured")

    now = int(time.time())
    exp = now + 60 * 10  # 10 minutes token
    claims = {
        "iss": LIVEKIT_API_KEY,
        "sub": identity,
        "nbf": now - 10,
        "exp": exp,
        "aud": "livekit",
        # LiveKit video grant
        "video": {
            "roomJoin": True,
            "room": room,
            "canPublish": can_publish,
            "canSubscribe": True,
            "canPublishData": True,
        },
    }
    token = jwt.encode(claims, LIVEKIT_API_SECRET, algorithm="HS256")
    # PyJWT >= 2 returns str
    return token  # type: ignore[return-value]


@router.get("/config")
def get_config() -> Dict[str, Any]:
    host = LIVEKIT_HOST.strip()
    # If not configured, or clearly local/http, use proxied path "/livekit" and let frontend prefix origin
    if not host or host.startswith("http://localhost") or host.startswith("http://127.0.0.1"):
        host = "/livekit"
    return {
        "host": host,
        "iceServers": _ice_servers(),
        "disabled": WEBRTC_DISABLE,
        "notes": [
            "If LiveKit is behind an nginx location /livekit/ ensure proxy_pass has a trailing slash.",
            "Prefer a dedicated HTTPS domain (e.g. https://livekit.example.com) for production.",
        ],
    }


@router.get("/token")
def get_token(
    room: str = Query("plastination", description="Room name to join"),
    identity: Optional[str] = Query(None, description="Client identity; autogenerated if blank"),
    role: str = Query("viewer", description="viewer|publisher"),
) -> Dict[str, str]:
    try:
        ident = identity or f"web-{uuid.uuid4().hex[:8]}"
        can_publish = role == "publisher"
        token = _build_access_token(ident, room, can_publish=can_publish)
        return {
            "token": token,
            "identity": ident,
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/ingress/create")
def create_rtmp_ingress(
    room: str = Query("plastination"),
    name: str = Query("pi-cam"),
) -> Dict[str, str]:
    """Create an RTMP ingress on the LiveKit Ingress service and return URL + stream key.
    Requires LIVEKIT_HOST, LIVEKIT_API_KEY, LIVEKIT_API_SECRET and livekit-api package.
    """
    try:
        from livekit import api as lk  # type: ignore
    except Exception as e:
        raise HTTPException(status_code=501, detail=f"livekit-api not installed: {e}")

    host = LIVEKIT_HOST
    if not host:
        raise HTTPException(status_code=500, detail="LIVEKIT_HOST not configured")
    if not LIVEKIT_API_KEY or not LIVEKIT_API_SECRET:
        raise HTTPException(status_code=500, detail="LIVEKIT API credentials not configured")

    try:
        client = lk.ApiClient(host=host, api_key=LIVEKIT_API_KEY, api_secret=LIVEKIT_API_SECRET)
        req = lk.CreateIngressRequest(
            input_type=lk.IngressInput.RTMP_INPUT,
            name=name,
            room_name=room,
        )
        resp = client.ingress.create_ingress(req)
        return {
            "rtmp_url": resp.rtmp.url,
            "stream_key": resp.stream_key,
            "room": room,
            "ingress_id": resp.ingress_id,
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/health")
def health() -> Dict[str, Any]:
    """Return quick health summary for WebRTC setup.
    Checks: env vars, reachability of LiveKit signaling endpoint, ICE servers presence.
    """
    host_cfg = LIVEKIT_HOST.strip()
    effective_host = host_cfg or "/livekit"
    ice = _ice_servers()
    api_creds = bool(LIVEKIT_API_KEY and LIVEKIT_API_SECRET)
    reachability: Optional[str] = None

    # Attempt a TCP connect for hostname:port if absolute URL given
    if effective_host.startswith("http"):
        try:
            # Parse host:port
            from urllib.parse import urlparse
            u = urlparse(effective_host)
            port = u.port or (443 if u.scheme == "https" else 80)
            with socket.create_connection((u.hostname, port), timeout=2):
                reachability = "tcp-ok"
        except Exception as e:
            reachability = f"tcp-failed: {e}"[:160]
    else:
        # Relative path: try local HTTP GET via nginx proxy (assumes same origin)
        try:
            # This will raise if not running under a public server; keep optional
            with urllib.request.urlopen(effective_host + ("/" if not effective_host.endswith("/") else "")) as _resp:
                reachability = f"http-status-{_resp.status}"
        except Exception as e:
            reachability = f"http-failed: {e}"[:160]

    recommendations = []
    if not host_cfg:
        recommendations.append("Set LIVEKIT_HOST to a full https:// domain for production (current uses proxied /livekit path).")
    if not api_creds:
        recommendations.append("Set LIVEKIT_API_KEY and LIVEKIT_API_SECRET; required for token issuing and ingress creation.")
    if not ice:
        recommendations.append("Provide LIVEKIT_ICE_SERVERS (STUN/TURN) to ensure remote clients can receive media.")
    if WEBRTC_DISABLE:
        recommendations.append("WEBRTC_DISABLE is active; unset it to enable WebRTC.")

    return {
        "livekit_host_env": host_cfg or None,
        "effective_host": effective_host,
        "api_credentials_configured": api_creds,
        "ice_servers_count": len(ice),
        "disabled": WEBRTC_DISABLE,
        "reachability": reachability,
        "recommendations": recommendations,
    }


@router.get("/diagnostics")
def diagnostics() -> Dict[str, Any]:
    """More detailed diagnostics including token generation attempt (without exposing secret)."""
    diag: Dict[str, Any] = {}
    h = health()
    diag.update(h)
    # Attempt a viewer token (won't expose secret)
    try:
        if h["api_credentials_configured"]:
            dummy_identity = "diag-" + uuid.uuid4().hex[:6]
            token = _build_access_token(dummy_identity, "plastination", can_publish=False)
            diag["token_issuance"] = "ok"
            diag["sample_token_prefix"] = token[:24] + "..."
        else:
            diag["token_issuance"] = "skipped"
    except Exception as e:
        diag["token_issuance"] = f"error: {e}"[:160]
    return diag
