from __future__ import annotations

import os
import time
import uuid
from typing import Any, Dict, List

import jwt
from fastapi import APIRouter, HTTPException, Query

router = APIRouter(prefix="/webrtc", tags=["webrtc"])


# Helpers to read env with defaults
LIVEKIT_HOST = os.getenv("LIVEKIT_HOST", "http://localhost:7880")
LIVEKIT_API_KEY = os.getenv("LIVEKIT_API_KEY", "")
LIVEKIT_API_SECRET = os.getenv("LIVEKIT_API_SECRET", "")
# Comma-separated list like: "stun:stun.l.google.com:19302,turns:turn.example.com:5349?transport=tcp"
LIVEKIT_ICE_SERVERS_RAW = os.getenv("LIVEKIT_ICE_SERVERS", "")


def _ice_servers() -> List[Dict[str, Any]]:
    urls_raw = [u.strip() for u in LIVEKIT_ICE_SERVERS_RAW.split(",") if u.strip()]
    if not urls_raw:
        return []
    # If using TURN static auth secret, you can generate ephemeral credentials here instead of static user/pass.
    # For now, return URL-only servers; coturn with static-auth-secret supports long-term creds, but LiveKit client
    # can use url-only for public TURN with no auth, which is NOT recommended. We encourage setting up TURN credentials.
    return [{"urls": urls_raw}]


def _build_access_token(identity: str, room: str, can_publish: bool = False) -> str:
    if not LIVEKIT_API_KEY or not LIVEKIT_API_SECRET:
        raise RuntimeError("LIVEKIT_API_KEY/SECRET not configured")

    now = int(time.time())
    exp = now + 60 * 10  # 10 minutes token
    claims = {
        "iss": LIVEKIT_API_KEY,
        "sub": identity,
        "nbf": now - 10,
        "exp": exp,
        "aud": "livekit",
        # LiveKit video grant
        "video": {
            "roomJoin": True,
            "room": room,
            "canPublish": can_publish,
            "canSubscribe": True,
            "canPublishData": True,
        },
    }
    token = jwt.encode(claims, LIVEKIT_API_SECRET, algorithm="HS256")
    # PyJWT >= 2 returns str
    return token  # type: ignore[return-value]


@router.get("/config")
def get_config() -> Dict[str, Any]:
    return {
        "host": LIVEKIT_HOST,
        "iceServers": _ice_servers(),
    }


@router.get("/token")
def get_token(
    room: str = Query("plastination", description="Room name to join"),
    identity: str = Query(None, description="Client identity; autogenerated if blank"),
    role: str = Query("viewer", description="viewer|publisher"),
) -> Dict[str, str]:
    try:
        ident = identity or f"web-{uuid.uuid4().hex[:8]}"
        can_publish = role == "publisher"
        token = _build_access_token(ident, room, can_publish=can_publish)
        return {
            "token": token,
            "identity": ident,
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
