from __future__ import annotations

import os
import time
import uuid
from typing import Any, Dict, List, Optional

import jwt
from fastapi import APIRouter, HTTPException, Query

router = APIRouter(prefix="/webrtc", tags=["webrtc"])


# Helpers to read env with defaults
# Prefer an HTTPS or proxy path to avoid mixed-content from HTTPS pages
LIVEKIT_HOST = os.getenv("LIVEKIT_HOST", "")
LIVEKIT_API_KEY = os.getenv("LIVEKIT_API_KEY", "")
LIVEKIT_API_SECRET = os.getenv("LIVEKIT_API_SECRET", "")
# Comma-separated list like: "stun:stun.l.google.com:19302,turns:turn.example.com:5349?transport=tcp"
LIVEKIT_ICE_SERVERS_RAW = os.getenv("LIVEKIT_ICE_SERVERS", "")
WEBRTC_DISABLE = os.getenv("WEBRTC_DISABLE", "0") not in ("0", "false", "False", "")


def _ice_servers() -> List[Dict[str, Any]]:
    urls_raw = [u.strip() for u in LIVEKIT_ICE_SERVERS_RAW.split(",") if u.strip()]
    if not urls_raw:
        return []
    # If using TURN static auth secret, you can generate ephemeral credentials here instead of static user/pass.
    # For now, return URL-only servers; coturn with static-auth-secret supports long-term creds, but LiveKit client
    # can use url-only for public TURN with no auth, which is NOT recommended. We encourage setting up TURN credentials.
    return [{"urls": urls_raw}]


def _build_access_token(identity: str, room: str, can_publish: bool = False) -> str:
    if not LIVEKIT_API_KEY or not LIVEKIT_API_SECRET:
        raise RuntimeError("LIVEKIT_API_KEY/SECRET not configured")

    now = int(time.time())
    exp = now + 60 * 10  # 10 minutes token
    claims = {
        "iss": LIVEKIT_API_KEY,
        "sub": identity,
        "nbf": now - 10,
        "exp": exp,
        "aud": "livekit",
        # LiveKit video grant
        "video": {
            "roomJoin": True,
            "room": room,
            "canPublish": can_publish,
            "canSubscribe": True,
            "canPublishData": True,
        },
    }
    token = jwt.encode(claims, LIVEKIT_API_SECRET, algorithm="HS256")
    # PyJWT >= 2 returns str
    return token  # type: ignore[return-value]


@router.get("/config")
def get_config() -> Dict[str, Any]:
    host = LIVEKIT_HOST.strip()
    # If not configured, or clearly local/http, use proxied path "/livekit" and let frontend prefix origin
    if not host or host.startswith("http://localhost") or host.startswith("http://127.0.0.1"):
        host = "/livekit"
    return {
        "host": host,
        "iceServers": _ice_servers(),
        "disabled": WEBRTC_DISABLE,
    }


@router.get("/token")
def get_token(
    room: str = Query("plastination", description="Room name to join"),
    identity: Optional[str] = Query(None, description="Client identity; autogenerated if blank"),
    role: str = Query("viewer", description="viewer|publisher"),
) -> Dict[str, str]:
    try:
        ident = identity or f"web-{uuid.uuid4().hex[:8]}"
        can_publish = role == "publisher"
        token = _build_access_token(ident, room, can_publish=can_publish)
        return {
            "token": token,
            "identity": ident,
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/ingress/create")
def create_rtmp_ingress(
    room: str = Query("plastination"),
    name: str = Query("pi-cam"),
) -> Dict[str, str]:
    """Create an RTMP ingress on the LiveKit Ingress service and return URL + stream key.
    Requires LIVEKIT_HOST, LIVEKIT_API_KEY, LIVEKIT_API_SECRET and livekit-api package.
    """
    try:
        from livekit import api as lk  # type: ignore
    except Exception as e:
        raise HTTPException(status_code=501, detail=f"livekit-api not installed: {e}")

    host = LIVEKIT_HOST
    if not host:
        raise HTTPException(status_code=500, detail="LIVEKIT_HOST not configured")
    if not LIVEKIT_API_KEY or not LIVEKIT_API_SECRET:
        raise HTTPException(status_code=500, detail="LIVEKIT API credentials not configured")

    try:
        client = lk.ApiClient(host=host, api_key=LIVEKIT_API_KEY, api_secret=LIVEKIT_API_SECRET)
        req = lk.CreateIngressRequest(
            input_type=lk.IngressInput.RTMP_INPUT,
            name=name,
            room_name=room,
        )
        resp = client.ingress.create_ingress(req)
        return {
            "rtmp_url": resp.rtmp.url,
            "stream_key": resp.stream_key,
            "room": room,
            "ingress_id": resp.ingress_id,
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
